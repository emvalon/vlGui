# @file picture2array.py
# @author Weilong Shen (valonshen@foxmail.com)
# @brief
# @version 0.2
# @date 2025-04-27
#
# Copyright © 2021 - 2025 Weilong Shen (valonshen@foxmail.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import argparse
from PIL import Image, ImageOps
import tkinter as tk

TOOL_VERSION="v0.1.0"

parse = argparse.ArgumentParser()
parse.add_argument("-f", "--file", default="image", help="file name")
parse.add_argument("-d", "--driver", default="ssd1306", choices=["ssd1306"], help="driver chip which will be used")
parse.add_argument("-t", "--threshold", default=180, type=int, help="the threshold to be referenced")
parse.add_argument("-w", "--width", default=0, type=int, help="resized width")
parse.add_argument("-hi", "--height", default=0, type=int, help="resized height")
parse.add_argument("-o", "--output", default="None", help="output path")
parse.add_argument("-e", "--edit", action='store_true', help="Edit the image")
parse.add_argument("-r", "--reverse", action='store_true', help="Reverse the color")


def ssd1306_save(f, w, h, pixels):
    n = 0
    row = 0

    f.write("    ")
    while 1:
        data = 0
        for col in range(w):
            offset = col % 8
            if pixels[col, row]:
                    data |= 1 << offset

            if (offset == 7) or (col is (w - 1)):
                f.write("0x{:02x}, ".format(data))
                data = 0
                n = n + 1
                if n >= 16:
                    n = 0
                    f.write("\n    ")
            
        # Move to the next line
        row = row + 1
        if row >= h:
            break

def prepare_image(file, imgSize, threshold, r):
    # 打开原图 转成灰度图
    img = Image.open(file).convert('RGBA')

    # 创建一个白色背景图像
    white_bg = Image.new("RGBA", img.size, (255, 255, 255, 255))

    # 粘贴原图，透明部分将变成白色
    white_bg.paste(img, (0, 0), img)

    img = white_bg.convert("RGB").convert("L")

    # 调整到固定大小
    if imgSize != (0, 0):
        img = img.resize(imgSize, Image.LANCZOS)

    # 二值化（黑白化）
    img = img.point(lambda p: 255 if p > threshold else 0, mode='1')

    #反转颜色
    if r:
        img = ImageOps.invert(img)
    
    return img

def generate_header_file(img, targetPath, args):
    with open(targetPath, 'w', encoding="utf-8") as f:
        incDefine = "_" + str(name_without_ext).upper() + "_H_"
        f.writelines("/* Generated by vlGui tool " + TOOL_VERSION + "\n")
        f.writelines(" * Size: " + str(args.width) + " x " + str(args.height) + "\n")
        f.writelines(" * Image's name: " + str(name_without_ext) + "\n")
        f.writelines(" * Driver: " + args.driver + "\n")
        f.writelines(" */\n")
        f.writelines("#ifndef " + incDefine + "\n")
        f.writelines("#define " + incDefine + "\n\n")
        f.writelines("const unsigned char " + str(name_without_ext) + "[] = {\n")

        f.write("    ")
        f.write("0x{:02x}, ".format(args.width & 0xff))
        f.write("0x{:02x}, ".format((args.width >> 8) & 0xff))
        f.write("0x{:02x}, ".format(args.height & 0xff))
        f.write("0x{:02x}, ".format((args.height >> 8) & 0xff))
        f.write("\n")

        if args.driver == "ssd1306":
            ssd1306_save(f, args.width, args.height, img.load())

        f.writelines("\n};\n\n#endif // " + incDefine)

# ******************************************************************************
# Image Editor
# ******************************************************************************
from PIL import Image, ImageTk
class vlGui_ImageEditor:

    def __init__(self, w, h, img):
        self.w = w
        self.h = h
        self.img = img

        self.root = tk.Tk()
        self.root.title("vlGui Image Editor")

        self.cell_size = 5
        self.margin = 30
        self.canvas = tk.Canvas(self.root)
        self.canvas.pack()

        self.canvas.bind("<Button-1>", self.toggle_pixel)
        self.canvas.bind("<MouseWheel>", self.on_mouse_zoom)        # Windows/macOS
        self.canvas.bind("<Button-4>", self.on_mouse_zoom)          # Linux scroll up
        self.canvas.bind("<Button-5>", self.on_mouse_zoom)          # Linux scroll down

        btn_frame = tk.Frame(self.root)
        btn_frame.pack(pady=5)
        tk.Button(btn_frame, text="Ok", command=self.root.quit).pack(side='left', padx=5)

    def draw_canvas(self):
        self.canvas.delete("all")
        self.canvas.config(scrollregion=(-self.margin, -self.margin, 
                                         self.w * self.cell_size, self.h * self.cell_size))
        self.canvas.config(width=self.w * self.cell_size + 2 * self.margin, 
                           height=self.h * self.cell_size + 2 * self.margin)
        # 画像素点
        for x in range(self.w):
            for y in range(self.h):
                val = self.img.getpixel((x, y))
                color = "black" if val == 0 else "white"
                rect = self.canvas.create_rectangle(
                    x * self.cell_size, y * self.cell_size, (x + 1) * self.cell_size, (y + 1) * self.cell_size,
                    fill=color, outline='gray'
                )

    def toggle_pixel(self, event):
        if (event.x < self.margin):
            return
        if (event.x >= self.margin + self.w * self.cell_size):
            return
        
        if (event.y < self.margin):
            return
        if (event.y >= self.margin + self.h * self.cell_size):
            return

        x = (event.x  - self.margin) // self.cell_size
        y = (event.y - self.margin) // self.cell_size

        old_pixel = self.img.getpixel((x, y))
        new_pixel = 255 if old_pixel == 0 else 0
        self.img.putpixel((x, y), new_pixel)
        self.draw_canvas()

    def on_mouse_zoom(self, event):
        MIN_CELL_SIZE = 2
        MAX_CELL_SIZE = 30
        # 更新 cell_size
        if event.delta > 0 or event.num == 4:
            self.cell_size = min(self.cell_size + 1, MAX_CELL_SIZE)
        else:
            self.cell_size = max(self.cell_size - 1, MIN_CELL_SIZE)
        self.draw_canvas()

    def loop(self):
        self.draw_canvas()
        self.root.mainloop()

# ******************************************************************************
# Main
# ******************************************************************************
if __name__ == '__main__':
    # Check if this file exits
    args = parse.parse_args()
    if not os.path.exists(args.file):
        print("File doesn't exit!\n")
        exit()
    # Get output path
    base_name = os.path.basename(args.file)
    name_without_ext = os.path.splitext(base_name)[0]
    bmpFilePath = "bmp/" + f"{name_without_ext}.bmp"

    name_without_ext = "vlGui_bmp" + name_without_ext[0].upper() + name_without_ext[1:]
    headerFilePath = "inc/" + f"{name_without_ext}.h"

    if args.output != "None":
        bmpFilePath = args.output + "/" + bmpFilePath
        headerFilePath = args.output + "/" + headerFilePath

    # Step 1: Prepare the iamge
    img = prepare_image(args.file, (args.width, args.height), args.threshold, args.reverse)
    args.width, args.height = img.size

    # Step 2: Open Image editor (UI)
    if args.edit:
        editor = vlGui_ImageEditor(args.width, args.height, img)
        editor.loop()
        
    # Step 3: Save Image
    os.makedirs(os.path.dirname(headerFilePath), exist_ok=True) 
    os.makedirs(os.path.dirname(bmpFilePath), exist_ok=True)

    generate_header_file(img, headerFilePath, args)
    img.save(bmpFilePath)

